#!/bin/bash
# Gabriel N Cloc Script [Technical Assessment #2]

# Version Information
readonly SCRIPT_AUTHOR="Gabriel Nieves"
readonly SCRIPT_CONTACT="taerkex@gmail.com"
readonly SCRIPT_VERSION="0.1"
readonly SCRIPT_UPDATED="May 14 2023"

# Global Variables
declare -ir UNIX_TIME=$(date +%s)
declare -r LOG_DIR="/tmp"
declare PKGMNGR=""

# Configurable Settings
declare -i opt_scan_mode="git"
declare -i opt_loglevel=0
declare -i opt_batch=0
declare opt_clocopts=""
declare -i opt_email_batch=0
declare opt_email_to=""
declare opt_email_subject=""
declare opt_email_from=""
declare opt_email_cc=""
declare opt_email_bcc=""

#######################################
# Main run of the script. It completes the operatiosn in the following order:
#   1. Ensures arguments are present
#   2. Check if --debug is set
#   3. Process all options and adjust variables
#   4. Determines which package manager to use on the current system
#   5. Installs any missing packages required
#   6. Sets the "To" address if it hasn't already been set
#   7. Makes sure there are still arguments set to load in
#   8. Iterates through and parses all inputs via cloc
#
# Globals:
#   None
# Arguments:
#   $1 - Accepts --debug as the FIRST argument to run in debug mode early
#   $@ - All arguments. These are parsed and used to adjust variables.
# Returns:
#   0 - On success
#   Non-zero - On failure (code varies by failure type)
#######################################
function main() {
  # Default output when no arguments are set
  if [ -z "$1" ]; then
    showSimpleHelp
    exit 1
  fi

  # Allow --debug early on for process argument testing
  [ "$1" = --debug ] && { opt_loglevel=2; shift; }

  # Get provided options
  get_options=$(getopt -o h,v -l help,verbose,debug,stdin,batch,cloc-options: -- "$@") || exitWithError INVALID_ARGUMENTS "$get_options"

  # This converts options to a shell-readable format, which 
  # allows for repeatable arguments (e.g. -vv)
  eval set -- "$get_options"

  echo_debug "Arguments: $get_options"

  # Do argument things
  while true; do
    echo_debug "Processing argument: $1 (\$2: $2)"
    case "$1" in
      -h|--help) showHelp; exit 1;;
      -v) [ $opt_loglevel -lt 2 ] && (( opt_loglevel++ ));;
      --verbose) opt_loglevel=1;;
      --debug) opt_loglevel=2;;
      -G|--git|--repo) opt_scan_mode="git";;
      -S|--stdin) opt_scan_mode="stdin";;
      -F|--files) opt_scan_mode="files";;
      --cloc-options) opt_clocopts="$2"; shift;;

      # End loop
      --) shift; break;;
      *) exitWithError INVALID_ARGUMENT "$1";;
    esac
    shift
  done

  # Install necessary packages for the script to continue running 
  determinePackageManager || exitWithError NO_PACKAGE_MANAGER
  for dep in cloc mailx sendmail sed; do
    checkPackage "$dep" || installPackage "$dep" || exitWithError MISSING_DEP
  done

  echo_debug "cloc Options:" $opt_clocopts

  # Take the first available argument as an email address if it hasn't
  # already been specified
  if [ -z "$opt_email_to" ]; then
    opt_email_to="$1"
    echo_debug "Email address has been set to \"$opt_email_to\""
    shift
  fi

  # Check if there are still arguments. If there aren't, show the command usage
  if [ -z "$1" ]; then
    showSimpleHelp
    return 1
  fi

  # Scan provided files
  case "$opt_scan_mode" in
    git)
      for INPUT_SOURCE in "$@"; do
        echo "Checking repository $INPUT_SOURCE"

        if ! cloneRepo "$INPUT_SOURCE"; then
          exitWithError REPO_ERROR
        fi

        # $opt_clocopts needs to remain unquoted in order to expand properly
        cloc $opt_clocopts "$INPUT_SOURCE"
      done
      ;;
    
    files)
      for INPUT_SOURCE in "$@"; do
        echo "Checking file: $INPUT_SOURCE"

        # Make sure the file exists, otherwise error out
        [ -f "$INPUT_SOURCE" ] || exitWithError MISSING_FILE "$INPUT_SOURCE"

        # $opt_clocopts needs to remain unquoted in order to expand properly
        cloc $opt_clocopts "$INPUT_SOURCE"
      done
      ;;

    stdin)
      echo "Checking code via stdin"
      cloc $opt_clocopts - < /dev/stdin
      ;;
  esac
}

#######################################
# Output provided text when the verbose conditions are met.
#
# Globals:
#   opt_loglevel
# Arguments:
#   $1 - Text to output
# Returns:
#   None
#######################################
function echo_verbose() {
  [ $opt_loglevel -ge 1 ] && echo "$1"
}

#######################################
# Output provided text when the debug conditions are met.
#
# Globals:
#   opt_loglevel
# Arguments:
#   $1 - Text to output
# Returns:
#   None
#######################################
function echo_debug() {
  [ $opt_loglevel -ge 2 ] && echo "[DEBUG] $1"
}

#######################################
# Print a shorter help snippet on how to use this script. This should typically
# be followed by a non-zero exit code in order to avoid the command being
# treated as a successful run.
#
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
#######################################
function showSimpleHelp() {
  echo "gn-cloc-script: missing arguments"
  echo "Usage: gn-cloc-script [OPTIONS]... EMAILDDR REPOURL..."
  echo
  echo "Try \"gn-cloc-script --help\" for more options and information."
}

#######################################
# Print a longer help page regarding this script. This should typically be
# followed by a non-zero exit code in order to avoid the command being
# treated as a successful run.
#
# Globals:
#   SCRIPT_AUTHOR
#   SCRIPT_CONTACT
#   SCRIPT_VERSION
#   SCRIPT_UPDATED
# Arguments:
#   None
# Returns:
#   None
#######################################
function showHelp() {
  local -r R="\e[0m"  # Reset
  local -r G="\e[2m"  # Gray
  local -r I="\e[3m"  # Italics
  local -r U="\e[4m"  # Underline
  local -r B="\e[97m" # Bold

  printf "${B}GN CLOC Script${R}

${B}SYNOPSIS${R}
  ${B}gn-cloc-script${R} [${U}option${R}]... [-t ${U}emailaddr${R}|${U}emailaddr${R}] ${U}repourl${R}...
  ${B}gn-cloc-script${R} [${U}option${R}]... --files [-t ${U}emailaddr${R}|${U}emailaddr${R}] ${U}file${R}...
  ${B}gn-cloc-script${R} [${U}option${R}]... --stdin [-t ${U}emailaddr${R}|${U}emailaddr${R}]

${B}DESCRIPTION${R}
  $(blockPrint 2 "Runs cloc (https://cloc.sourceforge.net/) against a provided repo, file(s), or stdin and sends the result to a configured email address.")

${B}OPTIONS${R}
  ${B}-h${R}, ${B}--help${R}
    $(blockPrint 4 "Show this help page.")

  ${B}-v${R}, ${B}--verbose${R}
    $(blockPrint 4 "Run script with verbose output.")

  ${B}-vv${R}, ${B}--debug${R}
    $(blockPrint 4 "Run script with debug output.")

${B}PARSING OPTIONS${R}
  ${B}-G${R}, ${B}--git${R}, ${B}--repo${R}
    $(blockPrint 4 "Clone a provided git repo URL to be scanned. This is the default behavior.")

  ${B}-F${R}, ${B}--files${R}
    $(blockPrint 4 "Parse the provided file list to be scanned.")

  ${B}-S${R}, ${B}--stdin${R}
    $(blockPrint 4 "Parse the provided stdin to be scanned.")

  ${B}--cloc-options${R} ${U}options...${R}
    $(blockPrint 4 "Passes provided options to the ${B}cloc${R} command.")

${B}EMAIL OPTIONS${R}
  ${B}-B${R}, ${B}--batch${R}
    $(blockPrint 4 "When running script on multiple files, sends a single email rather than an individual email for each file.")

  ${B}-t${R}, ${B}--to${R} ${U}emailaddr${R}
    $(blockPrint 4 "Set the destination address for the email. If not set, the email will be sent to current user's system mail queue.")

  ${B}-s${R}, ${B}--subject${R} ${U}value${R}
    $(blockPrint 4 "Set the subject for the resulting email notification. If not set, it will default to \"CLOC Analysis Report: # File(s)\".")

  ${B}-f${R}, ${B}--from${R} ${U}emailaddr${R}
    $(blockPrint 4 "Set the ${B}from${R} address email notification. If not set, it will default the system's default address.")

  ${B}-c${R}, ${B}--cc${R} ${U}emailaddr${R}
    $(blockPrint 4 "Set the ${B}cc${R} for the notification email. Use commas for multiple emails.")

  ${B}-b${R}, ${B}--bcc${R} ${U}emailaddr${R}
    $(blockPrint 4 "Set the ${B}bcc${R} for the notification email. Use commas for multiple emails.")

${B}AUTHOR${R}
  $(blockPrint 2 "Written by $SCRIPT_AUTHOR <$SCRIPT_CONTACT> for Checkmarx technical assessment #2.")

${B}VERSION${R}
  $(blockPrint 2 "Version $SCRIPT_VERSION. Last updated $SCRIPT_UPDATED.")
";
}

#######################################
# Print a text in an indented block based on input indentation
#
# In particular, it changes the style of the wrapping from the first paragraph
# below to the second with the spaces prior to each line being dependent on the
# first argument:
# 
#     Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod te
# mpor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, qui
# s nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
#
#     Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
#     tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
#     veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
#     commodo consequat.
#
# Globals:
#   None
# Arguments:
#   $1 - Number of spaces to prefix each line
#   $2 - Message to be wrapped
# Returns:
#   None
#######################################
function blockPrint() {
  tabs $1
  fold -s -w $(( $(tput cols) - $1 )) <<< "$2"  | sed -r "s/^/\t/g"
}

#######################################
# Outputs a fatal error message and exits the application. The output message
# is dependent on the provided arguments.
#
# Globals:
#   None
# Arguments:
#   $1 - Error ID of the message
#   $2 - Additional information used by a message. Varies between messages.
# Returns:
#   Non-zero exit code, typically 1. May change depending on error type.
#######################################
function exitWithError() {
  local ERROR_ID="$1"
  local ERROR_CODE=1
  local ERROR_MSG=""

  case "$ERROR_ID" in
    INVALID_ARGUMENT) shift; ERROR_MSG="Invalid argument received \"$@\"";;
    INVALID_ARGUMENTS) shift; ERROR_MSG="Invalid arguments received: $@\nUse -h to view help for valid arguments.";;
    MISSING_FILE) shift; ERROR_MSG="File not found \"$@\".";;
    FILES_AND_STDIN) shift; ERROR_MSG="Files were provided while stdin is enabled. Please specify only file arguments OR --stdin";;
    NO_PACKAGE_MANAGER) shift; ERROR_MSG="No valid package manager was found";;
    INVALID_PACKAGE_MANAGER) shift; ERROR_MSG="An invalid package manager was provided: $@";;
    MISSING_DEP) shift; ERROR_MSG="Failed to install missing dependency: $@";;
  esac

  [ -n "$ERROR_MSG" ] \
    && echo -e "Fatal Error: $ERROR_MSG" >&2 \
    || echo -e "Fatal Error: $ERROR_ID" >&2

  exit $ERROR_CODE
}

#######################################
# Determines which package manager to use for checking and installing 
#
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   0 - Function successfully found a compatible package manager
#   1 - Function failed to find a compatible package manager
#######################################
function determinePackageManager() {
  for PKGMNGR_SEARCH in dnf yum apt pkg pacman; do
    if [ -x "$(which "$PKGMNGR_SEARCH")" ]
    then
      PKGMNGR="$PKGMNGR_SEARCH"
      break
    fi
  done

  [ -n "$PKGMNGR" ] && return 0
  
  return 1
}

#######################################
# Check if a package is installed depending on the OS' package manager.
# Function will output a fatal error and exit the application upon a failure.
#
# Globals:
#   PKGMNGR
# Arguments:
#   $1 - Name of the package to check
# Returns:
#   None
#######################################
function checkPackage() {
  case "$PKGMNGR" in
    dnf|yum) rpm -q "$1" >/dev/null;;
    apt) apt -y -q install "$1";;
    pkg) pkg -y -q install "$1";;
    pacman) pacman -y -q install "$1";;
    *) exitWithError INVALID_PACKAGE_MANAGER "$PKGMNGR";;
  esac
}

#######################################
# Install a package using the OS' package manager
# Function will output a fatal error and exit the application upon a failure.
#
# Globals:
#   PKGMNGR
# Arguments:
#   $1 - Name of the package to install
# Returns:
#   None
#######################################
function installPackage() {
  echo "Script is installing missing dependencies: $1"
  case "$PKGMNGR" in
    dnf|yum) sudo -n "$PKGMNGR" -y -q install "$1";;
    apt) sudo -n apt -y -q install "$1";;
    pkg) sudo -n pkg -y -q install "$1";;
    pacman) sudo -n pacman -y -q -S install "$1";;
    *) exitWithError INVALID_PACKAGE_MANAGER "$PKGMNGR";;
  esac
}

#######################################
# Clones repository into a directory determined by the application
#
# Globals:
#   None
# Arguments:
#   $1 - Git repository URL
# Returns:
#   None
#######################################
function cloneRepo() {
  local repo_url="$1"
  local repo_dir=$(getRepoDirectory "$1")

  git clone "$repo_url" "$repo_dir"
}

#######################################
# Outputs a converted repository URL into the expected resulting directory name
#   Example #1: https://git.xtnet.link/Taerk/cloc-script.git -> cloc-script
#   Example #2: git@git.xtnet.link:Taerk/cloc-script.git -> cloc-script
#
# Globals:
#   None
# Arguments:
#   $1 - Git repository URL
# Returns:
#   None
#######################################
function getRepoDirectory() {
  basename "$1" | sed -r 's/\.git$//'
}

#######################################
# Sends an email using settings and content set by the application
#
# Globals:
#   opt_email_from
#   opt_email_to
#   opt_email_subject
#   opt_email_cc
#   opt_email_bcc
# Arguments:
#   stdin - Loads in stdin as the contents for the email
# Returns:
#   None
#######################################
function sendEmail() {
  [ -n "$opt_email_from" ] && local mailx_from="-r \"${opt_email_from}\""
  [ -n "$opt_email_to" ] && local mailx_to="\"${opt_email_to}\""
  [ -n "$opt_email_subject" ] && local mailx_subject="-s \"${opt_email_subject}\""
  [ -n "$opt_email_cc" ] && local mailx_cc="-c \"${opt_email_from}\""
  [ -n "$opt_email_bcc" ] && local mailx_bcc="-b \"${opt_email_from}\""

  # Variables below should remain unquoted in order to be expanded as valid arguments
  mail ${mailx_subject} ${mailx_from} ${mailx_cc} ${mailx_bcc} ${mailx_to} < /dev/stdin 
}

main "$@"